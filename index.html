<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="paintGame()">
<script>

    // This works on all devices/browsers, and uses IndexedDBShim as a final fallback
    var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;

    // Open (or create) the database
    var open = indexedDB.open("MyDatabase", 1);

    // Create the schema
    open.onupgradeneeded = function() {
        var db = open.result;
        var store = db.createObjectStore("MyObjectStore", {keyPath: "id", autoIncrement:true});
        // store.createIndex("name", "name", { unique: false });
        db.close();
    };


    //
    open.onsuccess = function() {
        // Start a new transaction
        var db = open.result;
        var tx = db.transaction("MyObjectStore", "readwrite");
        var store = tx.objectStore("MyObjectStore");
        // var index = store.index("IdIndex");
        //
        // // Add some data
        // // store.add({id: 0, name: {first: "John", last: "Doe"}, age: 42});
        // store.put({ nick: "Roger", time : 12, points: 12});
        //
        // // Query the data
        // var getJohn = store.getAll();//(12345);
        // // var getBob = index.get(["Smith", "Bob"]);
        //
        // getJohn.onsuccess = function() {
        //     console.log(getJohn.result);  // => "John"
        // };
        //
        // // getBob.onsuccess = function() {
        // //     console.log(getBob.result.name.first);   // => "Bob"
        // // };
        //
        // // Close the db when the transaction is done
        // tx.oncomplete = function() {
        //     db.close();
        // };
    }
    // updateDbRecords();

var myGamePiece;
var myObstacles = [];
var myBall;
var myScoreboard;
var dbRecords;

function addDbRecord(data) {
    var open = indexedDB.open("MyDatabase", 1);

    open.onsuccess = function() {
        // Start a new transaction
        var db = open.result;
        var tx = db.transaction("MyObjectStore", "readwrite");
        var store = tx.objectStore("MyObjectStore");

        store.put(data);

        updateDbRecords();

        tx.oncomplete = function() {
            db.close();
        };
    }

}

function updateDbRecords() {
    var open = indexedDB.open("MyDatabase", 1);
    let result

    open.onsuccess = function() {
        // Start a new transaction
        var db = open.result;
        var tx = db.transaction("MyObjectStore", "readwrite");
        var store = tx.objectStore("MyObjectStore");

        // Query the data
        var data = store.getAll();

        data.onsuccess = function() {
            console.log(data.result);
            dbRecords = data.result
            let records;

            dbRecords.forEach(record => {
                records += "Id: " + record.id + ", Nick: " + record.nick + ", time: " + record.time/1000 + ", points: " + record.points + "\n";
            })

            alert(records);
        };

        tx.oncomplete = function() {
            db.close();
        };
    }

}

function keyDownHandler(e) {
    switch (e.code) {
        case 'ArrowLeft':
            moveleft();
            break;
        case 'ArrowRight':
            moveright();
            break;
    }
}

function keyUpHandler(e) {
    switch (e.code) {
        case 'ArrowLeft':
        case 'ArrowRight':
            clearmove();
            break;
    }
}

function paintGame() {
    myGamePiece = new component(100, 20, "red", 250, 580);
    myBall = new ball(10, "green", 100, 200);
    myScoreboard = new scoreboard("black", 10, 400);
    for(i=0; i<3 ;i++) {
        for(j=0; j<10; j++) {
            myObstacles.push(new obstacle(50, 10, "blue",  25 +(j*55), 10 +(i*15)));
        }
    }
    myGameArea.paint();
}

var myGameArea = {
    isStarted : false,
    nick : "",
    time: 0,
    canvas : document.createElement("canvas"),
    paint: function() {
        this.canvas.width = 600;
        this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
    },
    start : function() {
        if (!this.isStarted)
        {
            let nickInput = document.getElementById("nickInput");
            if (nickInput.value === "") {
                alert("Provide nick first!")
            } else {
                this.clear();
                paintGame();
                this.time = 0;
                this.nick = nickInput.value;
                document.onkeydown = keyDownHandler;
                document.onkeyup = keyUpHandler;
                this.interval = setInterval(updateGameArea, 20);
                this.isStarted = true;
            }
        }
    },
    stop : function() {
        if (this.isStarted)
        {
            this.time = 0;
            clearInterval(this.interval);
            this.clear();
            paintGame();
            this.isStarted = false;
            myObstacles = [];
        }
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
    gameOver: function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.paint();
        addDbRecord({nick: myGameArea.nick, time: myGameArea.time, points: myScoreboard.getScore()});
        this.stop();
    }
}

function ball(radius, color, x, y)
{
	this.radius = radius;
    this.x = x;
    this.y = y;
    this.speedX = 5;
    this.speedY = 5;
    this.defaultSpeed = 5;
    this.goingDown = true;
    
    this.collision = function(pad) {
        if(ballComponentColliding(myBall, pad))
        {
            let speedMultipy = 1;
            if (myBall.x <= (pad.x + (0.1 * pad.width)) || myBall.x >= (pad.x + (0.9 * pad.width)))
            {
                speedMultipy = 3;
            } else if (myBall.x <= (pad.x + (0.3 * pad.width)) || myBall.x >= (pad.x + (0.7 * pad.width)))
            {
                speedMultipy = 2;
            } else if (myBall.x <= (pad.x + (0.4 * pad.width)) || myBall.x >= (pad.x + (0.6 * pad.width)))
            {
                speedMultipy = 1.5;
            }
            this.speedY = this.defaultSpeed * (-speedMultipy);
        }
        else if (this.y + this.radius >= 600  )
        {
            myGameArea.gameOver();
        } else if (this.y + this.radius <= 10){
            this.speedY *= -1;
        }
        else if (this.x + this.radius >= 600 || this.x + this.radius <= 10 ) {
            this.speedX *= -1;
        }
    }

    this.obstacleBounce = function() {
        this.speedY *= -1;
    }

    this.update = function() {
        ctx = myGameArea.context;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, true);
        ctx.fillStyle = color;
        ctx.closePath();
        ctx.fill();
    }
    
    this.newPos = function() {
    	this.collision(myGamePiece);
        this.x += this.speedX;
        this.y += this.speedY;
    }    
}

function obstacle(width, height, color, x, y) {
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    this.update = function () {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    this.clear = function () {
        ctx.clearRect(this.x, this.y, this.width, this.height);
    }

}

function component(width, height, color, x, y) {
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    this.newPos = function() {
        if ( (this.x + this.speedX) > 0 && (this.x + this.speedX) < (600 - 100))
        {
        	this.x += this.speedX;
        	this.y += this.speedY;
        }

    }
}

function scoreboard( color, x, y) {
    this.x = x;
    this.y = y;
    this.score = 0;
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillText("Score: " + this.score, this.x, this.y);
    }
    this.increase = function() {
        this.score++;
    }
    this.getScore = function() {
        return this.score;
    }
}

function updateGameArea() {
    myGameArea.clear();
    myBall.newPos();
    myBall.update();
    for(i=0; i < myObstacles.length; i++)
    {
        if(ballComponentColliding(myBall, myObstacles[i]))
        {
            myObstacles.splice(i, 1);
            myBall.obstacleBounce();
            i--;
            myScoreboard.increase();
            console.log("xxx");
        }
    }
    myScoreboard.update();
    if (myScoreboard.getScore() === 30)
    {
        myGameArea.gameOver();
    }
    myObstacles.forEach(obstacle => obstacle.update());
    myGamePiece.newPos();
    myGamePiece.update();
    myGameArea.time += 20;
}

function moveleft() {
    myGamePiece.speedX = -10;
}

function moveright() {
    myGamePiece.speedX = 10;
}

function clearmove() {
    myGamePiece.speedX = 0; 
    myGamePiece.speedY = 0; 
}


function ballComponentColliding(ball, component) {
    var distX = Math.abs(ball.x - component.x - component.width / 2);
    var distY = Math.abs(ball.y - component.y - component.height / 2);

    if (distX > (component.width / 2 + ball.radius)) {
        return false;
    }
    if (distY > (component.height / 2 + ball.radius)) {
        return false;
    }

    if (distX <= (component.width / 2)) {
        return true;
    }
    if (distY <= (component.height / 2)) {
        return true;
    }

    var dx = distX - component.width / 2;
    var dy = distY - component.height / 2;
    return (dx * dx + dy * dy <= (ball.radius * ball.radius));
}


</script>
<div style="text-align:center;width:480px;">
 
  <button onmousedown="moveleft()" onmouseup="clearmove()" ontouchstart="moveleft()">LEFT</button>
  <button onmousedown="moveright()" onmouseup="clearmove()" ontouchstart="moveright()">RIGHT</button><br><br>

</div>
<div style="text-align:center;width:480px;">
 
    <button onmousedown="myGameArea.start()">START</button>
    <button onmousedown="myGameArea.stop()">STOP</button><br><br>
  
  </div>
<div style="text-align:center;width:480px;">

    NICK: <input id="nickInput"></input>

</div>
<div style="text-align:center;width:480px;">

    <button onmousedown="updateDbRecords()">RECORDS</button>

</div>
</body>
</html>
