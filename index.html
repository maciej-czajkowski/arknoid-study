<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
/*canvas {*/
/*    border:1px solid #d3d3d3;*/
/*    background-color: #f1f1f1;*/
/*}*/
</style>
</head>
<body onload="paintGame()">
<script>

    // This works on all devices/browsers, and uses IndexedDBShim as a final fallback
    var indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || window.shimIndexedDB;

    // Open (or create) the database
    var open = indexedDB.open("MyDatabase", 1);

    // Create the schema
    open.onupgradeneeded = function() {
        var db = open.result;
        var store = db.createObjectStore("MyObjectStore", {keyPath: "id", autoIncrement:true});
        // store.createIndex("name", "name", { unique: false });
        db.close();
    };

    open.onsuccess = function() {
        // Start a new transaction
        var db = open.result;
        var tx = db.transaction("MyObjectStore", "readwrite");
        var store = tx.objectStore("MyObjectStore");
    }

var myGamePiece;
var myObstacles = [];
var myBall;
var balls = [];
var myScoreboard;
var dbRecords;
var specials = [];

function addDbRecord(data) {
    var open = indexedDB.open("MyDatabase", 1);

    open.onsuccess = function() {
        // Start a new transaction
        var db = open.result;
        var tx = db.transaction("MyObjectStore", "readwrite");
        var store = tx.objectStore("MyObjectStore");

        store.put(data);

        updateDbRecords();

        tx.oncomplete = function() {
            db.close();
        };
    }

}

function updateDbRecords() {
    var open = indexedDB.open("MyDatabase", 1);
    let result

    open.onsuccess = function() {
        // Start a new transaction
        var db = open.result;
        var tx = db.transaction("MyObjectStore", "readwrite");
        var store = tx.objectStore("MyObjectStore");

        // Query the data
        var data = store.getAll();

        data.onsuccess = function() {
            console.log(data.result);
            dbRecords = data.result
            let records;

            dbRecords.forEach(record => {
                records += "Id: " + record.id + ", Nick: " + record.nick + ", time: " + record.time/1000 + ", points: " + record.points + "\n";
            })

            alert(records);
        };

        tx.oncomplete = function() {
            db.close();
        };
    }

}

function keyDownHandler(e) {
    switch (e.code) {
        case 'ArrowLeft':
            moveleft();
            break;
        case 'ArrowRight':
            moveright();
            break;
    }
}

function keyUpHandler(e) {
    switch (e.code) {
        case 'ArrowLeft':
        case 'ArrowRight':
            clearmove();
            break;
    }
}

function paintGame() {
    myGamePiece = new component(100, 20, "red", 250, 580);
    // myBall = new ball(10, "green", 100, 200);
    console.log("sss");
    myScoreboard = new scoreboard("black", 10, 400);
    for(i=0; i<3 ;i++) {
        for(j=0; j<10; j++) {
            let random = Math.random() * 10;
            if (random < 5) {
                myObstacles.push(new obstacleA(50, 10, "blue",  25 +(j*55), 10 +(i*15)));
            } else {
                myObstacles.push(new obstacleB(50, 10, "purple",  25 +(j*55), 10 +(i*15)));
            }
        }
    }
    myGameArea.paint();
}

var myGameArea = {
    isStarted : false,
    nick : "",
    time: 0,
    canvas : document.createElement("canvas"),
    specials : 0,
    paint: function() {
        this.canvas.width = 600;
        this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
    },
    start : function() {
        if (!this.isStarted)
        {
            let nickInput = document.getElementById("nickInput");
            if (nickInput.value === "") {
                alert("Provide nick first!")
            } else {
                balls.push(new ball(10, "green", (Math.random()*100 + Math.random() * 60) , (Math.random()*100 +  200 + Math.random() * 40)));
                this.clear();
                paintGame();
                this.time = 0;
                this.nick = nickInput.value;
                document.onkeydown = keyDownHandler;
                document.onkeyup = keyUpHandler;
                this.interval = setInterval(updateGameArea, 20);
                this.isStarted = true;
            }
        }
    },
    stop : function() {
        if (this.isStarted)
        {
            this.time = 0;
            clearInterval(this.interval);
            this.clear();
            paintGame();
            this.isStarted = false;
            myObstacles = [];
        }
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
    gameOver: function() {
        return;
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.paint();
        addDbRecord({nick: myGameArea.nick, time: myGameArea.time, points: myScoreboard.getScore()});
        this.stop();
        balls = []
    }
}

function ball(radius, color, x, y)
{
	this.radius = radius;
    this.x = x;
    this.y = y;
    this.speedX = 5;
    this.speedY = 5;
    this.defaultSpeed = 3;
    this.goingDown = true;
    
    this.padCollision = function(pad) {
            if(ballComponentColliding(this, pad))
            {
                let speedMultiply = 1;
                if (this.x <= (pad.x + (0.1 * pad.width)) || this.x >= (pad.x + (0.9 * pad.width)))
                {
                    speedMultiply = 3;
                } else if (this.x <= (pad.x + (0.3 * pad.width)) || this.x >= (pad.x + (0.7 * pad.width)))
                {
                    speedMultiply = 2;
                } else if (this.x <= (pad.x + (0.4 * pad.width)) || this.x >= (pad.x + (0.6 * pad.width)))
                {
                    speedMultiply = 1.5;
                }
                this.speedY = this.defaultSpeed * (-speedMultiply);
            } else if (this.y + this.radius >= 600  )
                {
                    myGameArea.gameOver();
                } else if (this.y + this.radius <= 10){
                    this.speedY *= -1;
                }
                else if (this.x + this.radius >= 600 || this.x + this.radius <= 10 ) {
                    this.speedX *= -1;
                }
    }

    this.ballsCollision = function(balls) {
        balls.forEach(ball => {
            if ( this !== ball) {
                if (Math.sqrt(Math.pow(this.x - ball.x, 2) + Math.pow(this.y - ball.y, 2)) <= (this.radius * 2)) {
                    this.speedX *= (-1);
                    ball.speedX *= (-1);
                }
            }
        })
    }


        this.obstacleBounce = function() {
        this.speedY *= -1;
    }

    this.update = function() {
        ctx = myGameArea.context;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, true);
        ctx.fillStyle = color;
        ctx.closePath();
        ctx.fill();
    }
    
    this.newPos = function() {
    	this.padCollision(myGamePiece);
        this.ballsCollision(balls);
        this.x += this.speedX;
        this.y += this.speedY;
    }    
}

class obstacle {
    constructor(width, height, color, x, y) {
        this.width = width;
        this.height = height;
        this.color = color;
        this.x = x;
        this.y = y;
    }

    update = function () {
        this.ctx = myGameArea.context;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    clear = function () {
        ctx.clearRect(this.x, this.y, this.width, this.height);
    }
}

class obstacleA extends obstacle {
    constructor(width, height, color, x, y) {
        super(width, height, color, x, y);
    }

    executeSpecial() {

    }
}

class obstacleB extends obstacle {
    constructor(width, height, color, x, y) {
        super(width, height, color, x, y);
    }

    executeSpecial() {
        myGameArea.specials++;
        if (myGameArea.specials === 5) {
            balls.push(new ball(10, "green", (Math.random()*100 + Math.random() * 60) , (Math.random()*100 +  200 + Math.random() * 40)))
            myGameArea.specials = 0;
        }
    }
}

function component(width, height, color, x, y) {
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;
    this.x = x;
    this.y = y;
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    this.newPos = function() {
        if ( (this.x + this.speedX) > 0 && (this.x + this.speedX) < (600 - 100))
        {
        	this.x += this.speedX;
        	this.y += this.speedY;
        }

    }
}

function scoreboard( color, x, y) {
    this.x = x;
    this.y = y;
    this.score = 0;
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillText("Score: " + this.score, this.x, this.y);
    }
    this.increase = function() {
        this.score++;
    }
    this.getScore = function() {
        return this.score;
    }
}

function updateGameArea() {
    // myGameArea.clear();
    myGameArea.context.fillStyle = 'rgba(181, 211, 231, .6)';
    myGameArea.context.fillRect(0, 0, myGameArea.canvas.width, myGameArea.canvas.height)
    balls.forEach(ball => {
        ball.newPos();
        ball.update();
    })
    console.log(balls.length);
    for(i=0; i < myObstacles.length; i++)
    {
        balls.forEach(ball => {
            if(ballComponentColliding(ball, myObstacles[i]))
            {
                myObstacles[i].executeSpecial();
                myObstacles.splice(i, 1);
                ball.obstacleBounce();
                i--;
                myScoreboard.increase();
                console.log("xxx");
            }

        })
    }
    myScoreboard.update();
    if (myScoreboard.getScore() === 60)
    {
        myGameArea.gameOver();
    }
    myObstacles.forEach(obstacle => obstacle.update());
    myGamePiece.newPos();
    myGamePiece.update();
    myGameArea.time += 20;
}

function moveleft() {
    myGamePiece.speedX = -10;
}

function moveright() {
    myGamePiece.speedX = 10;
}

function clearmove() {
    myGamePiece.speedX = 0; 
    myGamePiece.speedY = 0; 
}


function ballComponentColliding(ball, component) {
    var distX = Math.abs(ball.x - component.x - component.width / 2);
    var distY = Math.abs(ball.y - component.y - component.height / 2);

    if (distX > (component.width / 2 + ball.radius)) {
        return false;
    }
    if (distY > (component.height / 2 + ball.radius)) {
        return false;
    }

    if (distX <= (component.width / 2)) {
        return true;
    }
    if (distY <= (component.height / 2)) {
        return true;
    }

    var dx = distX - component.width / 2;
    var dy = distY - component.height / 2;
    return (dx * dx + dy * dy <= (ball.radius * ball.radius));
}


</script>
<div style="text-align:center;width:480px;">
 
  <button onmousedown="moveleft()" onmouseup="clearmove()" ontouchstart="moveleft()">LEFT</button>
  <button onmousedown="moveright()" onmouseup="clearmove()" ontouchstart="moveright()">RIGHT</button><br><br>

</div>
<div style="text-align:center;width:480px;">
 
    <button onmousedown="myGameArea.start()">START</button>
    <button onmousedown="myGameArea.stop()">STOP</button><br><br>
  
  </div>
<div style="text-align:center;width:480px;">

    NICK: <input id="nickInput"></input>

</div>
<div style="text-align:center;width:480px;">

    <button onmousedown="updateDbRecords()">RECORDS</button>

</div>
</body>
</html>
